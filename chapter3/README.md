
# 窗口计算

在上一个章节中，我们尝试了有状态计算，分别实现了机器峰值、均值、中位值的监控。但是我们做的还远远不够，这节，我们将借助Flink提供的事件时间、watermark以及三种窗口计算（滑动窗口、计数窗口、会话窗口）实现更加稳定可靠的监控程序。



## 1. 窗口类型

什么是窗口呢？可以这么理解，在批处理中，我们一般经历如下过程：

1. 拉取所有数据
2. 计算
3. 输出结果

可以这么说，**一个批处理中，对应的窗口就是全部的数据。**在这里窗口的意义显得有点多余。

但是在流处理中却是必须的，因为**流数据是无穷无尽，类似一条不断的河流一样。**窗口的概念在监控系统中也十分的重要。例如，我们有某个域名每分钟的流量，我们想监控某个域名的平均带宽是否低于某个指定阈值。

> 带宽的含义：一些主机服务商会给带宽以不同的含义。在这里，带宽几乎变成一个单位时间内的流量概念。意思是单位时间内的下行数据总量。意味着如果一个公司提供每月2GB的带宽，意思就是用户每月最多只能下载2GB的内容。 —— 《维基百科》
>
> 这里为了简化：
>
> 1. 流量 = B（字节）当前流量值 
>
> 2. 带宽 = Mbps 带宽描述的是某段时间内，单位时间的流量。 其值 = （周期内总流量值）* 8 / 时间 / 1024 / 1024 

显然，我们的监控通常是监控当前的实时带宽更有价值。下面，我们分别来实现几种监控：

1. 每分钟计算当前这一分钟的实际带宽值，若低于100Mbps则产生报警
2. 每15s计算最近1分钟的实际带宽值，若低于100Mbps则产生报警

显然，方式2更加敏感，在监控中也更为常用。

对于方式1，有一个很重要的特性，即运行频率以及查看的时间区间（窗口大小）均设置为1分钟，是一种滚动的方式（把它想象成一个正方形滚动），这叫做 **滚动窗口**，它每次计算的数据是独一无二，无任何重叠的。

![tumbling-windows](./img/tumbling-windows.svg)

而对于第二项监控，它同样有一个很特殊的特性：它的运行频率以及查看的时间区间（时间窗口）不一致，是一种不断滑动，不断计算的过程，计算的过程中会有一部分数据被多次计算。

![sliding-windows](./img/sliding-windows.svg)

下面，我们来尝试编写实现代码：

``` java
StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
DataStream<String> text = env.socketTextStream("localhost", 8080);
text.map(new MapFunction<String, Tuple2<String, Long>>() {
    @Override
    public Tuple2<String, Long> map(String s) throws Exception {
        String[] items = s.split(" ");
        // 返回 channel -> 流量
        return new Tuple2<>(items[1], Long.parseLong(items[2]));
    }
}).keyBy(0)
        // 滚动窗口
        .timeWindow(Time.minutes(1))
        // 时间窗口
        // .timeWindow(Time.minutes(1), Time.seconds(15))
        .reduce((ReduceFunction<Tuple2<String, Long>>) (stringLongTuple2, t1) -> new Tuple2<>(stringLongTuple2.f0, stringLongTuple2.f1 + t1.f1))
        // 过滤出带宽值低于100Mbps域名
        .filter((FilterFunction<Tuple2<String, Long>>) stringLongTuple2 -> stringLongTuple2.f1 * 8.0 / 60 / 1024 / 1024 < 100)
        .print();
env.execute("BandwidthSlideMonitor");
```

从代码中可以发现，从滚动窗口到滑动窗口的转换非常简单，只要添加一个滑动周期参数即可。

下面测试输入输出：

```
2019-08-28T10:00:00 www.163.com 10000
2019-08-28T10:01:00 www.163.com 100
2019-08-28T10:02:00 www.163.com 100
2019-08-28T10:03:00 www.163.com 1000
```

运行结果：

1. 滚动时间窗口：等待1分钟左右得到输出  (www.163.com,11200) 即我们输入的所有流量值总和
2. 滑动时间窗口：等待15秒左右得到输出  (www.163.com,11200) 即我们输入的所有流量值总和



这里我们发现有个问题，即我们的时间窗口虽然是基于时间滑动的，但是数据却无法关联上时间的特性。即我们运行的时候，窗口说是要拉1分钟的数据，但是这个1分钟的数据的定义是从上次开始至触发期间收集到的数据，和数据所带有的数据时间完全无关。**在监控系统中，数据乱序、延迟是非常常见的，倘若无法基于正确的数据时间计算，很可能会出现错误的结果。因此这就涉及到“时间的概念”。**



### 1.1 时间类型

在流处理中有三种时间的概念：

1. 处理时间（Process Time）
2. 事件时间（Event Time）
3. 摄入时间 （Ingest Time）

对于我们上面的例子中，数据如下，假如我们是在2019-08-28T11:30:00时刻接受到下面这些数据。

```
2019-08-28T10:00:00 www.163.com 10000
2019-08-28T10:01:00 www.163.com 100
2019-08-28T10:02:00 www.163.com 100
2019-08-28T10:03:00 www.163.com 1000
```

倘若我们的逻辑是希望监控最近10分钟内的数据，那么实际上在30分的时候我们希望取到的是20分~30分发生的事情。这个时候我们若使用的是处理时间，那我们关注的是20分~30分期间**收到的数据**而不是实际上这些数据真正发生的时间。因此虽然我们的数据都是一个小时前的数据，我们也能触发计算。

处理时间是三种时间中使用最简单的一种，也是Flink中默认的时间。

但是，处理时间是 **不稳定**，严重依赖数据的时效性，如果数据延迟较大，那么可能在触发计算的时候没办法取到完整的数据，那么就可能导致错误的计算结果。同时，使用数据时间的计算程序无法 "复盘" 历史数据。例如，我们的监控程序修改了计算逻辑，并且我们获取了昨天一整天的数据，现在希望用新逻辑重跑这些数据输出结果，如果使用的是处理时间，由于处理时间依赖于系统时间，所以无法有效复盘。

所有，为了解决上述的问题，Flink 支持了**稳定的事件时间。**

事件时间，顾名思义，就是这条事件真实发生的时间，如上面的例子，分别表示域名在10点连续4分钟的时间。

使用时间时间时，我们就能获得准确的计算，我们复盘数据时，程序可依靠数据时间准确的触发计算。

**事件时间是Flink中最重要的特性之一。也是监控系统报警计算实现回测，保证正确性严重依赖的特性之一。**

最后一种时间是**摄取时间**，即进入Flink程序的时间，有时候，我们的数据没办法打上准确的事件时间，但是又希望比处理时间更精确，那么可以设置为摄取时间。

理想情况下（无任何传输延迟），事件时间（数据产生时间） = 摄入时间 = 处理时间。



## 1.2 编写代码

下面看看如何设置处理时间与事件时间：

``` java
StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
// 设置处理时间,如果不设置的话默认为处理时间
env.setStreamTimeCharacteristic(TimeCharacteristic.ProcessingTime);
```

处理时间的设置非常简单，假如没有设置系统也会默认使用处理时间。

而对于事件时间，**就必须要手工设置。**



对于事件时间的设置，除了上述的 setStreamTimeCharacteristic 方法以外，还有两个必须要做的事情：

1. 指定时间时间列
2. 设置Watermark

对于第一点很好理解，你必须告诉Flink你的事件时间是哪一列，而对于Watermark，我们现在来好好捋一捋概念。



### Watermark

在说watermark的概念前，我们可以先了解下 **数据乱序** 的概念。

